* cabal-auto-expose
  /cabal-auto-expose/ is a build time library which, like [[https://github.com/sol/hpack][hpack]], auto detects
  new and removed Haskell modules _and_ [[https://cabal.readthedocs.io/en/3.4/cabal-package.html#pkg-field-library-signatures][Backpack signatures]] in your project's
  sources and exposes them for you so you don't have to manually keep your
  .cabal file in sync. But unlike ~hpack~ it does not require you to write your
  project spec in a [[https://github.com/sol/hpack#tool-integration][third party format]] and so supports both Cabal and [[https://docs.haskellstack.org/en/stable/README/][~stack~]]
  workflows.

  Advantages of using this library over /hpack/:
  - Works great with both Cabal and ~stack~
  - Robust to overlapping directories across various components, eg. if your
    main project library sources are in ~src~ but the project also has an
    executable with sources in ~src/my-executable/~ those modules are excluded
    from the library's exposed module list.
  - Detects custom pre-processor modules: currently if you have a custom
    preprocessor that works on modules with the ~.myCustomExtension~ extension
    ~hpack~ will ignore them since it only knows about the preprocessors baked
    into Cabal.
  - Detects [[https://cabal.readthedocs.io/en/3.4/cabal-package.html?highlight=signatures#pkg-field-library-signatures][Backpack signatures]] and generally is able to keep pace with the
    newest features of Cabal because it directly uses the API.
  - Slightly less YAML in your life. :)

  Disadvantages over /hpack/:
  - ~hpack~ does more than just expose modules, it also detects license files,
    enables handy GLOB patterns in your data-files stanza, and more. This
    library currently does nothing more than auto exposing modules.
  - This library relies heavily on the Cabal API which makes no compatibility
    guarantees and neither will this library; it will keep pace with the latest
    stable version of Cabal. The cabal file format generated by ~hpack~ is much
    less likely to change.
  - Since ~hpack~ simply generates the .cabal file you don't need to incur a
    build time dependency which forces the project to use a custom ~Setup.hs~
    file ( more on that in 'Quick Start' ) and at the end of the day is yet
    another dependency.
  - ~hpack~ physically generates a .cabal file so if something isn't working you
    can just load it up into a text editor and figure it out. Since this library
    makes changes using the API directly it's much harder to debug a problem. In
    fact the next planned feature for this library is to render a .cabal file with
    explicitly listed modules for debugging ease.
    
  To get a better feel for how it all works check out the [[https://github.com/deech/cabal-auto-expose/blob/master/auto-expose-example-project/auto-expose-test-project.cabal#L1][demo]].

** Quick Start
   To get started add this library to your .cabal file as a build time
   dependency and create a custom Setup.hs.
   
   Adding a build time dependency requires setting the ~build-type~ of your
   project to ~Custom~ and adding a /custom-setup/ stanza. For example if your
   project is called ~my-awesome-project~ add this to ~my-awesome-project.cabal~:
   #+BEGIN_EXAMPLE
   ...
   build-type: Custom
   cabal-version: >=2.0
   
   custom-setup
     setup-depends:
       base >= 4.14 && < 5,
       Cabal >= 3.2.0.0 && < 4,
       cabal-auto-expose
   ...
   #+END_EXAMPLE

   At the root of ~my-awesome-project~ create a ~Setup.hs~ file with the contents:
   #+BEGIN_EXAMPLE
   import Distribution.Simple.AutoExpose as AutoExpose
   
   main :: IO ()
   main = AutoExpose.defaultMain
   #+END_EXAMPLE

   Then build your project with:
   #+BEGIN_EXAMPLE
   cabal configure && cabal build
   #+END_EXAMPLE
   and you should see modules that have not been listed in the ~exposed-modules~
   stanza being detected and compiled automatically.

   Due to an annoying limitation with Cabal on subsequent builds you'll have to:
   #+BEGIN_EXAMPLE
   cabal build --only-reconfigure && cabal build
   #+END_EXAMPLE
   
   ~cabal build --only-reconfigure~ forces Cabal to use this library to check
   for any new or removed modules and internally regenerate the
   [[https://hackage.haskell.org/package/Cabal-3.2.0.0/docs/Distribution-PackageDescription.html#t:PackageDescription][PackageDescription]] so they are properly recompiled; the normal ~cabal build~
   will work fine if nothing as been added/removed. To clarify your ~.cabal~
   file isn't touched, all changes are made to Cabal API data structures.
   
